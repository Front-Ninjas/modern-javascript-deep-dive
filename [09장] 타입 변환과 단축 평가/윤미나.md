# 9장 타입 변환과 단축 평가

## 9.1 타입 변환이란?
- **명시적 타입 변환** 또는 **타입 캐스팅** : 개발자가 의도적으로 값의 타입을 변환하는 것
  - ```jsx
    var x = 10;
    var str = x.toString();
    console.log(typeof str, str); //string 10.   -> X 변수의 값이 변경되 것은아님
    ```
- **암묵적 타입 변환** 또는 **타입 강제 변환** : 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것.
  - ```jsx
    var x = 10;
    var str = x+'';
    console.log(typeof str, str); //string 10.   -> X 변수의 값이 변경되 것은아님
    ```
- 타입 변환: 기존 원시값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것 (원시 값은 변경 불가능한 값)
- 주의할 점
  - 자신이 작성한 코드에 암묵적 코드 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지,
  그리고 타입 변환된 값으로 표현식이 어떻게 평가될 것인지 예측 가능해야 한다.
  - 타입 변환 결과를 예측하지 못하거나 예측이 결과와 일치하지 않는다면 오류를 생산할 가능성이 높아진다.
 
## 9.2 암묵적 타입 변환
자바스크립트 엔진이 표현식을 평가할 때 개발자의 의도와는 상관없이 암묵적으로 데이터 타입을 강제 변환 하는 것이다.

- 9.2.1 문자열 타입으로 변환
  - '+' 연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작한다.
    - ex) 1+ ''  -> '1'      //       1 + '2'  -> '12'
  - **템플릿 리터럴의 표현식 삽입**은 표현식의 평가 결과를 문자열 타입으로 암묵적으로 타입 변환한다.
    - ex) `1 + 1 = ${1 +1}`  -> "1 + 1 = 2"
- 9.2.2 숫자 타입으로 변환
  - 산술 연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 하므로, 숫자 타입이 아닌 피연산자는 숫자 타입으로 암묵적으로 타입 변환한다.
    - 피연산자를 숫자 타입으로 변환할 수 없는 경우에는 표현식의 평가 결과가 NaN이 된다.
  - 비교 연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 하므로, 숫자 타입이 아닌 피연산자는 숫자 타입으로 암묵적으로 타입 변환한다.
  - + 단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입으로 암묵적 타입 변환을 수행한다.
- 9.2.3 불리언 타입으로 변환
  - if문이나 for문에 사용하는 제어문 또는 조건시근 불리언 값으로 평가되어야 하는 표현식이다. 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환 한다.
  - **자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값 또는 Falsy 값으로 구분한다.**
    - false로 평가되는 Falsy 값: false, undefined, null, 0, -0, NaN, ' '(빈 문자열)

## 9.3 명시적 타입 변환
개발자 의도에 따라 명시적으로 타입을 변경하는 것이다.

- 9.3.1 문자열 타입으로 변환
  - String생성자 함수를 new 연산자 없이 호출하는 방법
    - ex) String(1);  // -> '1'
  - Object.prototype.toString 메서드를 사용하는 방법
    - ex) (1).toString(); // -> '1'
  - 문자열 연결 연산자를 이용하는 방법
    - ex) 1 + ''; // -> '1'
- 9.3.2 숫자 타입으로 변환
  - Number 생성자 함수를 new 연산자 없이 호출하는 방법
    - ex) Number('0'); // -> 0
  - parseInt, parseFloat 함수를 사용하는 방법 (문자열만 숫자 타입으로 변환 가능)
    - ex) parseInt('0'); // -> 0
  - '+' 단항 산술 연산자를 이용하는 방법
    - ex) + '0'; // -> 0
  - '*' 산술 연산자를 이용하는 방법
    - ex) '0' * 1; // -> 0
- 9.3.3 불리언 타입으로 변환
  - Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
    - ex) Boolean('x'); // -> true
  - ! 부정 논리 연산자를 두번 사용하는 방법
    - ex) !! 'x'; // -> true
   
## 9.4 단축 평가
- 9.4.1 논리 연산자를 사용한 단축 평가
  - 논리합 (||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.
  - ex) 'Cat' && 'Dog' // -> "Dog"
    - 'Cat'은 Truthy 값이므로 true로 평가. 'Dog'도 true이므로 **논리 연산의 결과를 결정하는 두번째 피연산자를 그대로 반환한다.**
  - ex) 'Cat' || 'Dog' // -> "Cat"
    - Cat은 true로 평가. 두번째 피연산자까지 평가해 보지 않아도 표현식을 평가할 수 있기 때문에 **논리 연산의 결과를 결정한 첫 번쨰 피연산자를 그대로 반환한다.**
  - **단축 평가: 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다. 표현식을 평가하는 도중에 평가 결과가 확정난 경우 나머지 평가 과정을 생략하는 것을 말한다.**
    - ```jsx
      var done = true;
      var message = '';
       
      // if 문
      if (done) message = '완료';   
      // 단축 평가
      message = done && '완료';
      console.log(message); // '완료'
      
      var done = false;
      var message = '';
       
      // if 문
      if (!done) message = '미완료';        
      // 단축 평가
      message = done || '미완료';
      console.log(message); // '미완료'

      //삼항 조건 연산자는 if...else 문을 대체할 수 있다.
      var done = true;
      var message = '';
       
      // if...else 문
      if (done) message = '완료';
      else      message = '미완료'; 
      console.log(message); // '완료'
       
      // 삼항 조건 연산자
      message = done ? '완료' : '미완료'; 
      console.log(message); // '완료'
      ```
- 9.4.2 옵셔널 체이닝 연산자
ES11에서 도입된 옵셔널 체이닝 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
  - ```jsx
    var elem = null;
    var value = elem?.value;
    console.log(value); // undefined
    ```
- 9.4.3 null 병합 연산자
ES11에서 도입된 null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
 - 변수에 기본값을 설정할 때 유용하다.
 - ```jsx
   var foo = null ?? 'default string';
   console.log(foo); // 'default string'
   ```
