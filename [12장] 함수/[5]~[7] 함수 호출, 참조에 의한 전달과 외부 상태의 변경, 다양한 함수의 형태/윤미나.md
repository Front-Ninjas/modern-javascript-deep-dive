# 12장 함수

## 12.5 함수 호출
함수는 함수를 가리키는 식별자와 함수 호출 연산자'( )'로 호출한다. 함수 호출 연산자 내에는 0개 이상의 인수를 쉼표로 구분해서 나열한다. 
- 12.5.1 매개변수와 인수
  - 함수를 실행하기 위해 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는 경우, **매개변수**를 통해 인수를 전달한다. (매개변수는 함수를 정의할 때 선언)ㄴ
  - 인수: 값으로 평가될 수 있는 **표현식**이어야 한다. (함수 호출할 때 지정, 개수와 타입에 제한이 없음)
  - 함수 호출 과정: 함수 몸체 내에서 암묵적으로 매개변수 생성 -> undefined로 초기화 -> 인수가 순서대로 할당
    - 함수는 **매개변수의 개수와 인수의 개수가 일치**하는지 체크하지 않는다.
    - 인수가 부족해 할당되지 않은 매개변수는 undefined
    - 매개변수보다 인수가 더 많으면 초과된 인수는 무시된다. (인수는 암묵적으로 arguments 객체의 프로퍼티로 보관됨)
- 12.5.2 인수 확인
  - 자바스크립트: 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.
  - ```jsx
    // 함수 내부에서 적절한 인수가 전달되었는지 확인은 가능
    // 부적절한 호출은 사전에 방지할 수 없음. 런타임에 에러 발생
    function add(x, y) {
      if (typeof x !== 'number' || typeof y !== 'number') {
        throw new TypeError('인수는 모두 숫자 값이어야 합니다.');
      }
      return x + y;
    }
     
    console.log(add(2, 'a')); // TypeError: 인수는 모두 숫자 값이어야 합니다.
    ```
  - 자바스크립트 상위 확장(타입스크립트와 같은 정적 타입을 선언할 수 있는)을 도입해서 컴파일 시점에 부적절한 호출을 방지하는 방법
  - arguments 객체를 통해 인수 개수를 확인하는 방법
  - 인수가 전달되지 않은 경우 **단축 평가를 사용해 매개변수에 기본값을 할당**하는 방법
    - 매개변수 기본값(인수를 전달하지 않았을 경우, undefined를 전달한 경우에만 유효)을 사용하면 함수 내에서 인수 체크 및 초기화를 간소화할 수 있다. 
- 12.5.3 매개변수의 최대 개수
  - ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않다.
  - 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야한다. (매개변수는 순서에 의미가 있음)
  - 이상적인 매개변수: 0개. 적을수록 좋다. 
    - 최대 3개 이상 넘지 않는 것을 권장한다.
    - 그 이상이 필요하다면 **하나의 매개변수를 선언하고 객체를 인수로 전달**하는 것이 유리하다.
      - 객채의 프로퍼티 키만 저확히 지정하면 매개변수의 순서는 신경쓰지 않아도 된다.
      - 인수의 의미를 설명하는 프로퍼티 키를 사용하게 되므로 코드의 가독성이 좋아지고 실수도 줄어드는 효과가 있다.
      - **주의할 점: 함수 외부에서 내부로 전달한 객체를 내부서 변경하면 함수 외부의 객체가 변경되는 *부수효과* 발생**
      - ```jsx
        // 매개변수가 많은 경우
        function createUser(name, age, gender, occupation, location) {
          // ...
        }
         
        // 객체를 인수로 사용
        function createUser(userInfo) {
          const { name, age, gender, occupation, location } = userInfo;
          // ...
        }
         
        createUser({
          name: 'John',
          age: 30,
          gender: 'male',
          occupation: 'developer',
          location: 'New York'
        });
        ```
  - **이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.**
- 12.5.4 반환문
  - return 키워드와 표현식(반환값)으로 이루어진 반환문을 사용해 실혀 결과를 함수외부로 반환 할 수 있다.
  - 역할
    - 함수의 실행을 중단하고 몸체를 빠져나간다. 반환문 이후에 다른 문이 존재하면 그 문은 무시된다.
    - return 키워드 뒤에 오는 표현식을 평가해 반환한다. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefind가 반환된다.
  - Node.js는 모듈 시스템에 의해 파일별로 독립적인 *파일 스코프*를 갖는다. -> Node.js 환경에서는 파일의 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않는다.


## 12.6 참조에 의한 전달과 외부 상태의 변경
원시 값은 값에 의한 전달, 객체는 참조에 의한 전달 방식으로 동작한다. 매개변수도 함수 내부에서 변수와 동일하게 취급되므로 타입에 따라 전달 방식이 달라진다.
  - 원시 타입 인수: 재할당을 통해 원시값을 새로운 원시값으로 교체 가능 (값 자체가 복사되어 매개변수에 전달되므로 부수효과 X)
  - 객체 타입 인수:재할당 없이 직접 할당된 객체를 변경 가능 (객체는 변경 가능한 값이므로 직접 변경 가능) (참조 값이 복사되어 매개변수에 전달되므로 부수효과 O)
- 함수가 외부 상태를 변경할 경우 상태 변화를 추적하기 어려워진다.
  - 코드의 복잡성 증가, 가독성을 해치는 원인
  - 이유: 객체가 변경할 수 있는 값이며, 참조에 의한 전달 방식으로 동작하기 때문에 발생하는 부작용
  - 객체 변경 추적 방법: 옵저버 패턴 등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 대처하는 추가 대응 필요
    - 객체를 불변 격체 (as const)로 만들어서 사용하는 것(객체를 변경 불가능한 값으로 만드는 것)
    - 객체의 상태 변경이 필요한 경우: 객체의 방어적 복사를 통해 원본 객체를 완전이 복제(깊은 복사)함으로써 새로운 객체를 생성하고 재할당을 통해 교체한다.
- 순수 함수: 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수
- 함수형 프로그래밍: 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임


## 12.7 다양한 함수의 형태


