# 12장 함수

## 12.5 함수 호출
함수는 함수를 가리키는 식별자와 함수 호출 연산자'( )'로 호출한다. 함수 호출 연산자 내에는 0개 이상의 인수를 쉼표로 구분해서 나열한다. 
- 12.5.1 매개변수와 인수
  - 함수를 실행하기 위해 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는 경우, **매개변수**를 통해 인수를 전달한다. (매개변수는 함수를 정의할 때 선언)ㄴ
  - 인수: 값으로 평가될 수 있는 **표현식**이어야 한다. (함수 호출할 때 지정, 개수와 타입에 제한이 없음)
  - 함수 호출 과정: 함수 몸체 내에서 암묵적으로 매개변수 생성 -> undefined로 초기화 -> 인수가 순서대로 할당
    - 함수는 **매개변수의 개수와 인수의 개수가 일치**하는지 체크하지 않는다.
    - 인수가 부족해 할당되지 않은 매개변수는 undefined
    - 매개변수보다 인수가 더 많으면 초과된 인수는 무시된다. (인수는 암묵적으로 arguments 객체의 프로퍼티로 보관됨)
  - ![image](https://github.com/user-attachments/assets/59d3eb21-5e2d-4b35-8d9d-5179046b43ca)

- 12.5.2 인수 확인
  - 자바스크립트: 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.
  - ```jsx
    // 함수 내부에서 적절한 인수가 전달되었는지 확인은 가능
    // 부적절한 호출은 사전에 방지할 수 없음. 런타임에 에러 발생
    function add(x, y) {
      if (typeof x !== 'number' || typeof y !== 'number') {
        throw new TypeError('인수는 모두 숫자 값이어야 합니다.');
      }
      return x + y;
    }
     
    console.log(add(2, 'a')); // TypeError: 인수는 모두 숫자 값이어야 합니다.
    ```
  - 자바스크립트 상위 확장(타입스크립트와 같은 정적 타입을 선언할 수 있는)을 도입해서 컴파일 시점에 부적절한 호출을 방지하는 방법
  - arguments 객체를 통해 인수 개수를 확인하는 방법
  - 인수가 전달되지 않은 경우 **단축 평가를 사용해 매개변수에 기본값을 할당**하는 방법
    - 매개변수 기본값(인수를 전달하지 않았을 경우, undefined를 전달한 경우에만 유효)을 사용하면 함수 내에서 인수 체크 및 초기화를 간소화할 수 있다. 
- 12.5.3 매개변수의 최대 개수
  - ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않다.
  - 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야한다. (매개변수는 순서에 의미가 있음)
  - 이상적인 매개변수: 0개. 적을수록 좋다. 
    - 최대 3개 이상 넘지 않는 것을 권장한다.
    - 그 이상이 필요하다면 **하나의 매개변수를 선언하고 객체를 인수로 전달**하는 것이 유리하다.
      - 객채의 프로퍼티 키만 저확히 지정하면 매개변수의 순서는 신경쓰지 않아도 된다.
      - 인수의 의미를 설명하는 프로퍼티 키를 사용하게 되므로 코드의 가독성이 좋아지고 실수도 줄어드는 효과가 있다.
      - **주의할 점: 함수 외부에서 내부로 전달한 객체를 내부서 변경하면 함수 외부의 객체가 변경되는 *부수효과* 발생**
      - ```jsx
        // 매개변수가 많은 경우
        function createUser(name, age, gender, occupation, location) {
          // ...
        }
         
        // 객체를 인수로 사용
        function createUser(userInfo) {
          const { name, age, gender, occupation, location } = userInfo;
          // ...
        }
         
        createUser({
          name: 'John',
          age: 30,
          gender: 'male',
          occupation: 'developer',
          location: 'New York'
        });
        ```
  - **이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.**
- 12.5.4 반환문
  - return 키워드와 표현식(반환값)으로 이루어진 반환문을 사용해 실혀 결과를 함수외부로 반환 할 수 있다.
  - 역할
    - 함수의 실행을 중단하고 몸체를 빠져나간다. 반환문 이후에 다른 문이 존재하면 그 문은 무시된다.
    - return 키워드 뒤에 오는 표현식을 평가해 반환한다. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefind가 반환된다.
  - Node.js는 모듈 시스템에 의해 파일별로 독립적인 *파일 스코프*를 갖는다. -> Node.js 환경에서는 파일의 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않는다.


## 12.6 참조에 의한 전달과 외부 상태의 변경
원시 값은 값에 의한 전달, 객체는 참조에 의한 전달 방식으로 동작한다. 매개변수도 함수 내부에서 변수와 동일하게 취급되므로 타입에 따라 전달 방식이 달라진다.
  - 원시 타입 인수: 재할당을 통해 원시값을 새로운 원시값으로 교체 가능 (값 자체가 복사되어 매개변수에 전달되므로 부수효과 X)
  - 객체 타입 인수:재할당 없이 직접 할당된 객체를 변경 가능 (객체는 변경 가능한 값이므로 직접 변경 가능) (참조 값이 복사되어 매개변수에 전달되므로 부수효과 O)
- 함수가 외부 상태를 변경할 경우 상태 변화를 추적하기 어려워진다.
  - 코드의 복잡성 증가, 가독성을 해치는 원인
  - 이유: 객체가 변경할 수 있는 값이며, 참조에 의한 전달 방식으로 동작하기 때문에 발생하는 부작용
  - 객체 변경 추적 방법: 옵저버 패턴 등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 대처하는 추가 대응 필요
    - 객체를 불변 격체 (as const)로 만들어서 사용하는 것(객체를 변경 불가능한 값으로 만드는 것)
    - 객체의 상태 변경이 필요한 경우: 객체의 방어적 복사를 통해 원본 객체를 완전이 복제(깊은 복사)함으로써 새로운 객체를 생성하고 재할당을 통해 교체한다.
- 순수 함수: 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수
- 함수형 프로그래밍: 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임


## 12.7 다양한 함수의 형태
- 12.7.1 즉시 실행 함수 (IIFE)
  - 정의: 함수 정의와 동시에 즉시 호출되는 함수
  - 특징
    - 단 한번만 호출되며 다시 호출할 수 없다.
    - 익명 함수를 사용하는 것이 일반적이다. (기명 즉시 실행 함수도 사용할 수 있긴 하다.)
    - 그룹 연산자 내의 기며함수는 함수 선언문이 아니라 *함수 리터럴*로 평가되며 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자이므로 다시 호출할 수는 없다.
    - 즉시 실행 함수는 반드시 **그룹 연산자(...)** 로 감싸야 한다.
  - 사용하는 이유
    - 전역 스코프를 오염시키지 않는다.
    - 변수나 함수 이름의 충돌을 방지할 수 있다.
    - private한 변수를 만들 수 있다.
  - 예시
    - ```jsx
      function foo() {}(); // -> function foo() {};(); 콜론이 암묵적으로 추가되어 에러 발생
      //함수 선언문 두의 (...)는 함수 호출 연산자가 아니라 그룹 연산자로 해석되고, 그룹 연산자에 피연산자가 없기 때문에 에러가 발생한다.
      // 그룹 연산자의 피연산자는 값으로 평가되므로 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.

      //함수 리터럴을 평가해서 함수 객체를 생성하는 일반적인 방법
      console.log(typeof (function f(){}));  //function
      ```
      
- 12.7.2 재귀 함수
  - 정의: 함수가 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수
  - 특징
    - 반복적인 처리를 위해 사용된다.
    - 반드시 탈출 조건이 있어야 한다.
    - **스택 오버플로우**에 주의해야 한다. (스택 오버플로우: 함수가 무한 호출될 때 발생되는 에러)
  - 장단점
    - 장점: 반복되는 처리를 반복문 없이 구현할 수 있다. (복잡한 알고리즘을 간단하고 명확하게 표현할 수 있다.)
    - 단점: 무한 반복에 빠질 위험이 있고, 깊은 재귀는 스택 오버플로우를 일으킬 수 있다.
    - 해결방법: 꼬리 재귀 최적화
  - 예시
    - ```jx
      function factorial(n){
        if (n<=1) return 1; //탈출 조건
        return n*factorial(n-1); //재귀 호출
      }

      console.log(factorial(3)); // 3! = 3*2*1 = 6
      ```
- 12.7.3 중첩 함수 (내부 함수)
  - 정의: 함수 내부에 정의된 함수 (외부 함수: 중첩 함수를 포함하는 함수)
  - 특징
    - 외부 함수 내에서만 호출 가능하다.
    - 주로 외부 함수를 돕는 헬퍼 함수 역할을 한다.
    - 외부 함수의 변수에 접근할 수 있다. (클로저)
  - 예시
    - ```jsx
      function outer() {
        var x = 1;
        
        function inner() {
          var y = 2;
          console.log(x + y);
        }
        
        inner();
      }
       
      outer(); // 3
      ```
- 12.7.4 콜백 함수
  - 정의: 다른 함수의 인자로 전달되어 나중에 호출되는 함수. 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
  - 고차 함수: 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
    - 콜백 함수를 자신의 일부분으로 합성한다.
    - 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.
    - 이때 고차 함수는 필요에 따라 콜백함수에 인수를 전달할 수 있다.
    - (고차 함수에 콜백 함수를 전달할 때 콜백 함수를 호출하지 않고 함수 자체를 전달해야 한다.)
  - 특징
    - 함수의 매개변수를 통해 다른 함수 내부로 전달된다.
    - 고차 함수에 의해 호출된다.
    - 비동기 처리나 이벤트 처리 등에 많이 사용한다.
  - 장점
    - 코드의 재사용성을 높인다.
    - 비동기 작업을 처리하기 용이하다.
    - 함수의 확장성을 높인다.
  - 주의사항: **콜백 지옥**에 빠지지 않도록 해야한다. 이를 해결하기 위해 promise나 async/await 등의 방법을 사용할 수 있다.
    - 콜백 지옥: 비동기 작업을 연속적으로 수행할 때 발생하는 문제
  - 예시
    - ```jsx
      function repeat(n, f) {
        for (var i = 0; i < n; i++) {
          f(i);
        }
      }

      // 콜백 함수가 고차 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 고차 함수에 전달하는 것이 일반적이다.
      // 익명함수 리터럴을 콜백 함수로 고차 함수에 전달한다.
      // 익명함수 ㄹ터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다. 
      repeat(5, function(i) {
        console.log(i);
      });
      ```
      
- 12.7.5 순수 함수와 비순수 함수
  - 순수 함수: 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수효과가 없는 함수
    - 특징
      - 동일한 인수에 대해 항상 동일한 값을 반환한다.
      - 외부 상태를 변경하지 않는다.
      - 부수 효과가 없다.
  - 비순수 함수: 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수효과가 있는 함수
    - 특징
      - 외부 상태에 의존하거나 변경한다.
      - 동일한 인수에 대해 다른 값을 반환할 수 있다.
      - 부수 효과가 있다.
  - 함수형 프로그래밍
    - 순수 함수와 보조 함수의 조합을 통해 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임
    - 로직 내에 존재하는 조건문, 반복문 제거하여 복잡성 해결
    - 변수 사용 억제, 생명주기 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다.
    - 순수 함수를 통해 부수효과를 최대한 억제해 오류를 피하고 프로그램의 안전성을 높이려는 노력의 일
  - 예시
    - ```jsx
      // (순수 함수)
      function add(a, b) {
        return a + b;
      }
      // (비순수 함수)
      var count = 0;
      function incrementCount() {
        return ++count;
      }
      ```


- 참고자료
  - https://valur.tistory.com/entry/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Deep-Dive-12%EC%9E%A5-%ED%95%A8%EC%88%98#%EC%9E%AC%EA%B7%80%20%ED%95%A8%EC%88%98-1
