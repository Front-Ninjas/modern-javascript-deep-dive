# 19장 프로토타입
자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.
- 자바스크립트를 이루고 있는 거의 모든것인 객체이다. (원시타입의 값을 제외한 나머지)

## 19.1 객체지향 프로그래밍
- 정의: 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임
- 실세계의 실체(사물이나 개념)를 인식하는데, 실체는 특징이나 성질을 나타내는 속성을 가지고 있고 이를 통해 실체를 인식하거나 구별한다.
- 추상화: 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것
- 객체: 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조. (상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조)
  - 상태: 프로퍼티
  - 동작: 메서드
## 19.2 상속과 프로토타입
- 상속: 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
  - 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.
  - 중복 제거 방법: 기존 코드 재사용
- 생성자 함수: 동일한 프로퍼티(메서드 포함) 구조를 갖는 객체를 여러 개 생성할 때 유용하다.
  - 동일한 메서드를 중복 소유하는 것은?: 불필요한 메모리 낭비, 퍼포먼스에 악영향
  - 메서드가 모든 인스턴스에서 동일한 내용으로 사용된다면 단 하나만 생성하여 모든 인스턴스에 공유하여 사용하는 것이 바람직하다.
  - 자바스크립트는 프로토타입을 기반으로 상속을 구현한다. (상속을 통해 불필요한 중복 제거)
  ```jsx
  function Circle(radius) {
	  this.radius = radius;
  }
  Circle.prototype.getArea = function () {
  	return Math.PI * this.radius ** 2;
  };
  const circle1 = new Circle(1);
  const circle2 = new Circle(2);
  console.log(circle1.getArea === circle2.getArea); // true
  ```
## 19.3 프로토타입 객체
- 프로토타입은 객체 간 상속을 구현하기 위해 사용된다.
  - 프로토타입 객체: 어떤 객체의 부모 객체 역할을 하며 그 객체에게 공유 프로퍼티를 제공한다.
  - 프로토타입 객체의 프로퍼티와 메서드를 상속받은 하위 객체: 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 그것들을 자유롭게 사용할 수 있다.
- [[Prototype]]: 모든 객체가 가지는 내부 슬롯
  - 내부 슬롯의 값: 프로토타입의 참조(null인 경우도 있음)
  - 저장되는 프로토타입: 객체 생성 방식에 의해 결정된다. (결정되면 [[Prototype]]에 저장된다.)
  -  [[Prototype]] 내부 슬롯에는 직접 접근이 불가능하다.
- 모든 객체는 하나의 프로토타입을 갖으며 그 프로토타입은 생성자 함수와 연결되어 있다.
  - __proto__ : 간접적으로 프로토타입에 접근할 수 있다.
  - constructor 프로퍼티: 생성자 함수에 접근할 수 있다.
  - prototype 프로퍼티: 프로토타입에 접근할 수 있다.
### 19.3.1 __proto__ 접근자 프로퍼티
[[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.
-  **__proto__: [[Get]], [[Set]] 프로퍼티 어트리뷰트를 갖는 접근자 프로퍼티**
  - 값을 갖지 않고 프로토타입의 참조 값을 취급하는 특수한 프로퍼티
  - 간접적으로 접근 -> 내부적으로 [[Get]]이 호출되어 프로토타입을 반환
  -  __proto__에 값을 할당하면 [[Set]]이 호출되어 프로토타입을 교체
  
- **__proto__: 상속을 통해 사용된다.**
  - __proto__는 모든 객체의 프로토타입 객체인 Object.prototype의 프로퍼티
  - 모든 객체는 상속을 통해 Object.prototype.__proto__를 사용할 수 있다.
  ```jsx
  const person = { name: "Lee" };
  // person 객체는 proto 프로퍼티를 소유하지 않는다.
  console.log(person.hasOwnProperty("proto")); // false
  // __proto__는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티다.
  console.log(Object.getOwnPropertyDescriptor(Object.prototype, "proto"));
  // {get: ƒ, set: ƒ, enumerable: false, configurable: true}
  // 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.
  console.log({}.proto === Object.prototype); // true
  ```
- **__proto__ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유**
	-  상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서이다.																			
	- 서로가 자신의 프로토타입이 되는 비정상적인 프로토타입 체인 **(순환 참조하는 체인)** 이 만들어지면 프로토타입 체인 종점이 존재하지 않기 때문에 프로토타입 체인에서 프로퍼티를 검색할 때 무한 루프에 빠진다.
  - 순환 참조 시 타입에러가 발생한다. 
  - 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다.
  - 아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 proto 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어 있다.

- **proto 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장되지 않는다.**
  - 모든 객체가 __proto__를 사용할 수 있는 것은 아니기 때문이다.
  - 직접적인 상속을 통해 Object.prototype을 상속받지 않는 객체를 생성할 수도 있기 때문이다.
  - -> __proto__ 접근자 프로퍼티를 사용할 수 없는 경우가 생긴다.

- proto 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우: Object.getPrototypeOf 메서드 사용
- 프로토타입을 교체하고 싶은 경우: Object.setPrototypeOf 메서드 사용

### 19.3.2 함수 객체의 prototype 프로퍼티
함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킨다.
```jsx
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty("prototype"); // -> true
// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty("prototype"); // -> false
```
- 화살표 함수와 ES6의 축약 메서드 표현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않는다.
- 모든 객체가 가지고 있는(정확히는 Object.prototype으로부터 상속받은) proto 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.
  - 하지만 이들 프로퍼티를 사용하는 주체가 다르다.
  ![image](https://github.com/user-attachments/assets/58af029a-13b7-4c17-ba28-6f63cb6be9de)

### 19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수
모든 프로토타입은 constructor 프로퍼티를 갖는다. 
- 객체의 입장에서 자신을 생성한 객체를 가리킨다.
- 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이뤄진다.
- 생성자 함수를 통해 새로운 객체를 생성해쓸 경우 생성된 객체에는 constructor 프로퍼티가 없다.
  - 생성된 객체의 프로토타입인 생성자함수.prototype에는  constructor 프로퍼티가 있다
  - 프로토타입의 constructor 프로퍼티를 상속받아 사용할 수 있다.
  
## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
객체를 생성하는 방법에는 new 연산자와 함께 생성자 함수를 호출하는 방식 외에도 리터럴 표기법으로 생성하는 방식이 있다. 
- ex) 객체 리터럴, 함수 리터럴, 배열 리터럴, 정규표현식 리터럴 등
- 리터럴 표기법에 의해 생성된 객체도 물론 프로토타입이 존재한다.
  - 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고는 단정할 수 없다.
- ```jsx
  const obj = {}; // 객체 리터럴로 생성
	console.log(obj.constructor === Object); // true
  ```
  - 객체 리터럴로 생성한 객체의 생성자 함수는 Object 생성자	함수와 constructor 프로퍼티로 연결되어 있다.
- **Object 생성자 함수 내부의 동작 방식**
  - Object 생성자 함수에 인수를 전달하지 않거나 undefined 또는 null을 인수로 전달하면서 호출
  - -> 내부적으로는 추상 연산 OrdinaryObjectCreate를 호출하여 Object.prototype을 프로토타입으로 갖는 빈 객체를 생성한다.
- 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체 아니다.
  - 그러나 추상 연산을 통해 Object.prototype을 프로토타입으로 갖는 점에서 동일하다고 볼 수 있다.
- 함수 객체(Function 생성자 함수를 호출하여 생성한 함수)
  - 렉시컬 스코프를 만들지 않는다.
  - 전역 함수인 것처럼 스코프를 생성한다.
  - 클로저를 만들지 않는다.
  - **=> 함수 선언문이나 함수 표현식으로 정의한 함수는 Function 생성자 함수로 생성된 것이 아니다. 하지만 constructor 프로퍼티를 통해 확인해보면 Function 생성자 함수로 연결되어 있다.**
  
- 리터럴 표기법으로 생성된 객체도 상속을 위해 프로토타입이 필요하다. -> 가상적인 생성자 함수를 갖는다.
- 프로토타입은 생성자 함수와 더불어 생성되며, 언제나 쌍으로 존재한다.

**결국 리터럴 표기법으로 생성한 객체는 사실 엄밀히 말해 생성자 함수에 의해 생성된 객체는 아니지만, 상속 관계를 위해 생성자 함수와 연결되어야 한다는 점에서 생성자 함수로 생성한 객체와 큰 차이는 없다고 볼 수 있다.
**


참고자료
- https://valur.tistory.com/entry/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Deep-Dive-19%EC%9E%A5-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85?category=1153940#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%20%EA%B0%9D%EC%B2%B4-1






