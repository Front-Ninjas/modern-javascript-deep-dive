### 프로토타입의 생성 시점
- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.
- 축약표현으로 정의되지 않은 일반 함수로 정의한 함수 객체는 new 연산자와 함께 생성자 함수로서 호출할 수 있다.
- 함수 정의가 호이스팅되어 평가될 때 함수 객체가 생성되고 이 때 생긴 프로토타입이 생성자 함수 prototype 프로퍼티에 바인딩 된다.
- 생성된 프로토타입은 언제나 Object.prototype

#### 빌트인 생성자 함수와 프로토타입 생성 시점
- Object, String, Number 등 빌트인 생성자 함수도 일반 함수 처럼 생성자 함수가 생성되는 시점에 프로토타입이 생성된다.
- 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다.
- 생성자 함수 프로토타입은 이미 있고 객체를 우리가 생성하면 [[Prototype]]에 생성된 프로토타입이 들어간다.
- 예를들면 Person을 만들면 [[Prototype]]에 Object.prototype이 있는 것이다.

### 객체 생성 방식과 프로토타입 결정
- 객체는 객체 리터럴, Object 생성자 함수, Object.create메서드 등으로 생성되는데 이것 모두 추상 연산자 OrdinaryObjectCreate에 의해 생성된다.
- OrdinaryObjectCreate가 자신이 생성할 객체의 프로토타입을 인수로 받아서 추가할 프로퍼티 목록을 옵션으로 전달하고 [[Prototype]] 내부 슬롯에 할당하고 객체를 반환한다.
- 예를들면 const obj = { x : 1 };가 있으면 OrdinaryObjectCreate를 js엔진이 호출해서 인수로 Object.prototype을 넘긴다.
- 객체 리터럴과 Object 생성자 함수에 의해 객체 생성 방식은 살짝 차이가 있다
- Object 생성자 함수방식은 빈객체를 생성하고 프로퍼티를 추가한다.
- 객체 리터럴 방식은 객체 리터럴 내부에 프로퍼티를 추가한다.

> 살짝 다른데 별로 안크다. 결과는 똑같다.
> 프로토타입도 객체이고 모든 객체는 프로토타입을 가지므로 프로토타입도 자신의 프로토타입을 갖는다.
> 부모의 유전자가 내려오는 느낌

#### 생성자 함수에 의해 생성된 객체의 프로토타입
- new 연산자와 함께 생성자 함수를 호출하면 OrdinaryObjectCreate의 인수는 prototyope 프로퍼티에 바인딩 되어 있는 객체
- ex) Person 생성자로 만들었다면 Person.prototype을 [[Prototype]]으로 가지고있다.
- Person.prototype에 프로퍼티를 추가하면 자식이랑 체인으로 연결되어 있어서 자식도 쓸 수 있다.

### 프로토타입 체인
- js는 객체 프로퍼티에 뭐가 업다면 [[Prototype]]을 따라서 계속 위로 올라가면서 찾는다 이거를 프로토타입 체인이라고 부른다.
- 최상위 프로토타입인 Object.prototype의 [[Protytype]]의 값은 null이다.
