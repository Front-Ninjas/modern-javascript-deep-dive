
# 24장 클로저 (Closure)

> **정의**: *클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합*이다. (MDN)
> 즉, **함수가 생성될 때의 스코프를 기억하는 능력**.

---

## 24.1 렉시컬 스코프 (Lexical Scope)

* 자바스크립트는 \*\*렉시컬 스코프(정적 스코프)\*\*를 따른다.
* 즉, 함수의 상위 스코프는 \*\*"함수를 어디서 호출했는지"가 아니라 "함수를 어디서 정의했는지"\*\*로 결정된다.
* 상위 스코프는 **함수 정의 시점에 정적으로 결정**되고 이후 변하지 않는다.

### 예시

```js
const x = 1;

function outerFunc() {
  const x = 10;
  function innerFunc() {
    console.log(x); // 10
  }
  innerFunc();
}
outerFunc();
```

* `innerFunc`는 **정의된 위치** 기준으로 `outerFunc`의 렉시컬 환경을 상위 스코프로 기억한다.
* 호출 위치(`outerFunc`)가 아니라 **정의 위치**가 중요하다.

---

## 24.2 함수 객체의 내부 슬롯 \[\[Environment]]

* 모든 함수 객체는 `[[Environment]]` 내부 슬롯에 \*\*자신이 정의된 렉시컬 환경의 참조(=상위 스코프)\*\*를 저장한다.
* 이 덕분에 함수는 **호출될 때마다 상위 스코프를 다시 탐색**할 수 있다.

### 함수 실행 과정 요약

1. **함수 정의 평가**

   * 함수 객체가 생성될 때, `[[Environment]]`에 \*\*정의된 환경(상위 스코프)\*\*를 저장.
2. **함수 호출 시**

   * 새로운 함수 렉시컬 환경 생성
   * 이 렉시컬 환경의 "외부 렉시컬 환경 참조"가 `[[Environment]]`에 저장된 상위 스코프를 가리킴.

---

## 24.3 클로저와 렉시컬 환경

* **클로저**: 외부 함수의 실행 컨텍스트가 종료된 뒤에도, 내부 함수가 외부 변수(자유 변수)를 참조할 수 있는 현상.

```js
function outer() {
  const x = 10;
  return function inner() {
    console.log(x); // outer의 변수에 접근 가능
  };
}

const innerFunc = outer();
innerFunc(); // 10
```

### 동작 원리

1. `outer` 실행 → `outer`의 렉시컬 환경 생성
2. `inner` 정의 시 → `[[Environment]]`에 `outer`의 렉시컬 환경 저장
3. `outer` 실행 종료 후 컨텍스트 제거 → 하지만 렉시컬 환경은 `inner`가 참조 중이므로 GC 대상 아님
4. `inner` 호출 시 → `outer`의 렉시컬 환경을 기억하고 접근 가능

---

### 🔑 클로저 조건

* 중첩 함수가 \*\*상위 스코프의 식별자(자유 변수)\*\*를 참조한다.
* 중첩 함수가 외부 함수보다 오래 살아남는다.

즉, **상태 유지 + 은닉**이 가능한 함수만 클로저로 취급한다.

---

## 24.4 클로저의 활용

### 1) 상태 유지와 은닉

```js
const increase = (function () {
  let num = 0; // 은닉된 변수
  return function () {
    return ++num;
  };
})();
console.log(increase()); // 1
console.log(increase()); // 2
```

* `num`은 외부에서 직접 접근 불가
* 오직 반환된 함수만 `num`을 변경 가능

---

### 2) 모듈 패턴

```js
const Counter = (function () {
  let num = 0;

  return {
    increase() {
      return ++num;
    },
    decrease() {
      return num > 0 ? --num : 0;
    },
  };
})();

console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 0
```

* 객체의 **메서드만 접근 가능**, 내부 상태(`num`)는 은닉됨

---

### 3) 고차 함수 활용

```js
function makeCounter(aux) {
  let counter = 0;
  return function () {
    counter = aux(counter);
    return counter;
  };
}

const increaser = makeCounter((n) => ++n);
const decreaser = makeCounter((n) => --n);

console.log(increaser()); // 1
console.log(increaser()); // 2
console.log(decreaser()); // -1
```

* 함수형 프로그래밍에서 상태 변경 로직을 \*\*보조 함수(aux)\*\*로 분리 가능
* 불변성을 유지하면서도 상태를 캡슐화할 수 있음

---

## 24.5 캡슐화와 정보 은닉

* **캡슐화**: 프로퍼티 + 메서드를 묶는 것
* **정보 은닉**: 특정 데이터(상태)를 외부에서 접근 못하게 보호

### 예시 (클로저로 private 구현)

```js
function Person(name, age) {
  this.name = name;
  let _age = age; // private

  this.sayHi = function () {
    console.log(`Hi! I am ${this.name}, ${_age} years old.`);
  };
}

const me = new Person("Lee", 20);
me.sayHi(); // 접근 가능
console.log(me._age); // undefined (은닉됨)
```

⚠️ 단점: 인스턴스마다 `sayHi`가 중복 생성됨
➡️ 프로토타입 메서드로 빼면 `age`에 접근 불가 → 클로저와 프로토타입은 함께 쓰기 어려움

---

### 💡 최신 JS 문법: `#private` 필드

```js
class Person {
  #age; // private

  constructor(name, age) {
    this.name = name;
    this.#age = age;
  }

  sayHi() {
    console.log(`Hi! I am ${this.name}, ${this.#age} years old.`);
  }
}
```

* ES2022 표준 → 완전한 정보 은닉 지원

---

## 24.6 클로저 사용 시 자주 발생하는 실수

### 문제 상황 (var 사용)

```js
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}
console.log(funcs[0]()); // 3
console.log(funcs[1]()); // 3
console.log(funcs[2]()); // 3
```

* `var`는 함수 레벨 스코프 → `i`가 전역에서 공유됨
* 모든 함수가 **최종 값 3**을 참조

---

### 해결 방법

1. **즉시 실행 함수(IIFE)로 클로저 만들기**

```js
for (var i = 0; i < 3; i++) {
  funcs[i] = (function (id) {
    return function () {
      return id;
    };
  })(i);
}
```

2. **`let` 사용 (블록 스코프)**

```js
for (let i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}
```

3. **고차 함수 사용**

```js
const funcs = Array.from({ length: 3 }, (_, i) => () => i);
funcs.forEach((f) => console.log(f())); // 0 1 2
```

👉 승은 님 노트에 딱 맞게 **면접 질문 예상 포인트**도 따로 정리해드릴까요? (예: "클로저란 무엇인가요?", "자바스크립트에서 클로저 활용 사례?", "var와 let의 클로저 차이점?")
