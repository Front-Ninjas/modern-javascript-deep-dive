### 변수의 생명주기
#### 지역 변수의 생명주기
전역 변수의 생명주기는 애플리케이션의 생명주기와 같다.
지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.
지역 변수도 호이스팅이 일어난다.
호이스팅은 스코프 단위로 일어난다.

변수는 스코프가 소멸될 때 까지 유효한데 누군가 메모리 공간을 참조하고 있다면 해제되지 않고 확보된 상태로 남는다. 
> 이에 대해서는 클로저에서 살펴본다는데 기대가 된다

#### 전역 변수의 생명주기
- 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 객체다.
- 예를들어 브라우저는 window 서버 사이드 환경은 global 객체를 의미한다.
- 전역 객체는 표준 빌트인 객체 (Object, String, Number, Function 등)와 전역 변수와 전역 함수를 프로퍼티로 갖는다.

- 즉 전역 변수의 생명주기는 애플리케이션의 생명주기다.

### 전역변수의 문제점
- 긴 생명주기
  - 생명주기가 길어서 의도치 않은 재할당이 이뤄지면 추적이 어렵다.
  - 지역변수는 짧은 기간만 메모리를 소비하고 없어져서 오류가 발생활 확률이 낮다.
- 네임스페이스 오염
  - 파일이 분리 되어 있어도 하나의 전역 스코프를 공유한다는 것이다. 다른 파일에서 예상치 못한 결과가 생길 수 있다.
- 암묵적 결합
- 스코프 체인 상에서 종점에 존재
  - 전역 변수의 검색 속도가 가장 느리다.

### 전역 변수의 사용을 억제하는 방법
#### 즉시실행함수
```javascript
  (function () { var foo = 10; }());
```
- 모든 변수는 즉시 실행되고 없어진다.
- 이 방법은 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다.
#### 네임스페이스 객체
- 객체를 생성해 전역 변수처럼 사용하고 싶은 프로퍼티를 추가하여 사용하는 방법
- 좋아보이진 않음

#### 모듈 패턴
모듈 패턴은 클로저 기반으로 동작하여 전역변수를 억제하고 캡슐화까지 구현할 수 있다고 한다.

> 클로저를 빨리 공부하고 싶다.

보통 객체 지향 언어는 클래스에 public, private, protected가 있는데 js 는 없다.
근데 모듈 패턴을 통해 정보 은닉을 구현할 수 있다.

> 레전드 신기신기했다.
> 이게 아까 누가 공간을 점유하고 있다면 스코프가 안사라진다고 했던 그거 같다.
```javasript
  var Counter = (function () {
	//private 변수
	var num = 0;
  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
        return ++num;
      },
      decrease() {
        return --num;
      }
  }
}());

//private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); //undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

#### ES6 모듈
- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.
- 그래서 var로 선언한 전역변수는 더이상 window객체의 프로퍼티가 아니다.
- 신기하구만

