# 14장 전역 변수의 문제점

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

변수는 선언에 의해 생성되고, 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다. 즉, 변수는 생성되고 소멸되는 **생명 주기(lifecycle)**를 갖는다.

만약 변수에 생명 주기가 없다면, 한 번 선언된 변수는 프로그램이 종료되지 않는 한 메모리 공간을 영원히 점유하게 된다. 따라서 변수의 생명 주기를 이해하는 것은 효율적인 메모리 관리와 성능 최적화를 위해 중요하다.

#### 지역 변수의 생명 주기
- 함수 내부에서 선언된 지역 변수는 **함수가 호출될 때 생성되고, 함수가 종료되면 소멸**한다.
- 즉, 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.
- 하지만 지역 변수가 함수보다 오래 생존하는 경우도 있다.
  - 변수의 생명 주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지다.
  - 지역 변수는 **함수가 생성한 스코프에 등록**된다.
  - 만약 스코프가 소멸되지 않고 참조되고 있다면, 지역 변수도 함께 유지된다.

#### 호이스팅과 스코프
- **호이스팅**은 스코프를 기준으로 동작한다.
- 지역 변수의 경우, 선언이 해당 **지역 스코프의 선두로 끌어 올려진 것처럼 동작**한다.

```javascript
var x = 'global';

function foo() {
    console.log(x); // undefined
    var x = 'local';
}

foo();
console.log(x); // global
```

위 코드에서 `console.log(x)`는 `undefined`를 출력한다. 이는 `var x = 'local'`의 선언 부분이 **호이스팅**되어 `var x;`로 함수 스코프의 최상단에서 선언되었지만, 초기화는 해당 줄에서 이루어지기 때문이다.

---

### 14.1.2 전역 변수의 생명 주기

- `var` 키워드로 선언한 **전역 변수는 전역 객체(global object)의 프로퍼티**가 된다.
- 즉, 전역 변수의 생명 주기는 **전역 객체의 생명 주기와 일치**한다.

#### 전역 객체(Global Object)
- 전역 객체는 **자바스크립트 엔진이 가장 먼저 생성하는 특수한 객체**로, 환경에 따라 다음과 같이 다르게 나타난다.
  - 브라우저 환경: `window`
  - Node.js 환경: `global`
- 브라우저 환경에서는 웹 페이지가 닫힐 때까지 `window` 객체가 유지되므로, **전역 변수 또한 웹 페이지를 닫을 때까지 메모리에 남는다.**

```javascript
var globalVar = "I'm global!";
console.log(window.globalVar); // I'm global!
```

전역 객체의 속성으로 등록되므로, `window.globalVar`처럼 접근할 수도 있다.

---

## 14.2 전역 변수의 문제점

### 1. 암묵적 결합
- 전역 변수는 **모든 코드가 참조하고 변경할 수 있어 암묵적 결합(implicit coupling)**을 허용한다.
- 즉, 전역 변수를 사용하는 모든 코드가 **상태를 공유**하므로 의도치 않게 상태가 변경될 가능성이 높아진다.
- 코드가 길어질수록 유지보수가 어렵고, 가독성이 떨어진다.

### 2. 긴 생명 주기
- 전역 변수는 프로그램이 종료될 때까지 메모리를 점유한다.
- 사용하지 않더라도 메모리에 남아 있으므로, 불필요한 메모리 낭비가 발생할 수 있다.
- 또한 전역 변수의 생명 주기가 길면 **변수의 상태를 변경할 기회가 많아지고, 버그 발생 가능성이 높아진다.**

### 3. 스코프 체인 상에서 종점에 존재
- 자바스크립트 엔진은 **스코프 체인(scope chain)**을 따라 변수를 검색한다.
- 지역 변수가 있으면 지역 변수를 먼저 찾고, 없으면 상위 스코프를 따라가며 검색한다.
- 전역 변수는 **스코프 체인의 종점에 위치**하므로, 검색 속도가 가장 느리다.

### 4. 네임스페이스 오염
- 같은 전역 스코프에서 변수명이 충돌하면 의도치 않은 재할당이 발생할 수 있다.
- 여러 라이브러리를 사용할 경우, 전역 변수를 사용하면 충돌이 발생할 가능성이 커진다.

---

## 14.3 전역 변수의 사용을 억제하는 법

전역 변수의 사용을 억제하고 보다 안전한 코드를 작성하는 방법을 살펴보자.

### 14.3.1 즉시 실행 함수 (IIFE: Immediately Invoked Function Expression)

```javascript
(function () {
    var foo = 10;
    console.log(foo); // 10
})();

console.log(foo); // ReferenceError: foo is not defined
```

즉시 실행 함수(IIFE)를 사용하면 **모든 변수를 함수 내부의 지역 변수로 선언할 수 있어** 전역 변수의 생성을 방지할 수 있다. 라이브러리 개발 시 많이 사용된다.

---

### 14.3.2 네임스페이스 객체

전역 변수 대신, **네임스페이스 객체를 생성하여 전역 변수를 그룹화**할 수 있다.

```javascript
var MYAPP = {};
MYAPP.name = "Lee";
console.log(MYAPP.name); // Lee
```

또한, 네임스페이스 객체 내에 객체를 계층적으로 추가할 수도 있다.

```javascript
var MYAPP = {};
MYAPP.person = {
    name: "Lee",
    address: "Seoul"
};
console.log(MYAPP.person.name); // Lee
```

하지만, **네임스페이스 객체 자체가 전역 변수이므로 완벽한 해결책은 아니다.**

---

### 14.3.3 모듈 패턴 (Module Pattern)

**모듈 패턴**은 **즉시 실행 함수와 클로저(closure)를 활용**하여 변수를 보호하는 기법이다.

```javascript
var Counter = (function () {
    var num = 0; // private 변수
    return {
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        }
    };
})();

console.log(Counter.num); // undefined
console.log(Counter.increase()); // 1
```

- `num` 변수는 즉시 실행 함수 내부에서만 접근 가능하여 **캡슐화(encapsulation)**가 가능하다.
- 전역 변수 없이 **상태를 안전하게 관리**할 수 있다.

---

### 14.3.4 ES6 모듈 (ES6 Module)

- ES6부터는 **모듈을 사용하여 전역 변수의 사용을 억제**할 수 있다.
- `import`와 `export`를 활용하여 모듈 간의 의존성을 관리한다.

```javascript
// module.js
export const name = "Lee";

// main.js
import { name } from "./module.js";
console.log(name); // Lee
```

ES6 모듈은 자체적인 **모듈 스코프**를 제공하여 `var` 키워드로 선언한 변수도 전역 객체의 프로퍼티가 되지 않는다.

---

## 결론
전역 변수는 유지보수성과 성능 측면에서 많은 문제점을 야기할 수 있다. 따라서 **즉시 실행 함수, 네임스페이스 객체, 모듈 패턴, ES6 모듈** 등의 기법을 활용하여 전역 변수의 사용을 최소화하는 것이 바람직하다.
