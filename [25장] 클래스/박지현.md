<img width="591" height="628" alt="image" src="https://github.com/user-attachments/assets/4485479e-f414-4bcc-a7c5-35d3485eebfd" />## 클래스
### 클래스는 프로토 타입의 문법적 설탕인가?
- 클래스는 프로토타입 기반의 인스턴스를 생성하지만 동일하게 동작하지는 않는다.
- 클래스는 super, extends 키워드가 지원되고 호이스팅이 발생하지 않는 것 처럼 동작한다.
- 그래서 클래스는 문법적 설탕이라기 보다 새로운 객체 생성 매커니즘이 더 합당하다.
### 클래스 정의
- 파스칼 케이스 사용해라
- 클래스는 함수다 js에서 함수는 일급객체다 그래서 클래스는 일급객체다.

### 클래스 호이스팅
- 클래스는 런타임 이전에 평가되어 함수 객체를 생성하는데 생성된 함수 객체는 생성자 함수(constructor)이다.
- 생성자 함수는 함수 정의가 평가되는 시점에 프로토타입도 생긴다.
- 클래스는 호이스팅이 안 일어나는 것 처럼 보이지만 let, const 키워드로 선언한 변수처럼 호이스팅 된다 TDZ에 빠진다.
- TDZ는 메모리에 등록이 되었지만 초기화가 안됬거나 위험해서 아직 못 쓰는 상태\

### 인스턴스 생성
- new를 붙이면 생성자 함수로 인식되고 안 붙이면 일반 함수로 인식됨 만드려면 new 반드시 붙여야 한다.

### 메서드
- 클래스 몸체에 정의할 수 있는 메서드는 생성자, 프로토타입 메서드 정적 메서드가 있다.
- constructor
  - 인스턴스 생성, 초기화를 위한 메서드
- 클래스가 평가되어 생성된 함수 객체나 클래스가 생성한 인스턴스에 constructor메서드가 없다!!
- constructor는 메서드로 해석되는 것이 아니라 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다.
<img width="200" height="200" alt="image" src="https://github.com/user-attachments/assets/bfe020e2-e001-4200-833a-4effae01c56a" />
- 프로토타입 메서드를 넣는 방법은 객체에 Person.prototype으로 넣거나 클래스 안에서 프로토타입 메서드를 선언하면 된다.
- 결국 클래스는 생성자 함수랑 인스턴스를 쉽게 만들어 주는 생성자 함수다
- 정적 메서드
  - 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
  - 클래스에 바인딩 되어 함수 객체 평가 시점에 생김, 프로토타입 안에 생기는 것이 아닌 Person 클래스 안에 생긴다.
  - 그래서 프로토타입 체인상에 없어서 메서드를 상속받을 수 없고 Person.sayHi()이렇게 써야된다.
  - 정적 메서드는 그래서 this 못씀
  - 정적 메서드의 장점은 하나의 네임스페이스로 관련된 유틸 함수들을 모아놓으면 관리하고 구조화하기 쉽다.

### 클래스의 인스턴스 생성 과정
- new 연산자와 함께 클래스를 호출하면 클래스 내부 메서드 [[Constructor]]가 호출됨.
```javascript
class Person {
    constructor(name) {
        // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
        console.log(this);  // Parson {}
        console.log(Object.getPrototypeOf(this) === Person.prototype);  // true

        // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
        this.name = name;

        // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
    }
}
```
### 프로퍼티 
- 인스턴스 프로퍼티
  - constructor내부에 정의된 프로퍼티들
- 접근자 프로퍼티
  - 다른 데이터나 값을 읽거나 저장할 때 사용하는 접근자 함수 ex) get, set
- 원래는 클래스 필드 constructor에서만 선언할 수 있었는데 업데이트 되서 이제 자바 처럼 선언해도 된다.
- 매개변수로 함수를 넘겨서 클래스 필드에 인스턴스 메서드를 만드는 것은 별로 좋지 않을 수 있다.

- private 필드
  - 원래 private 필드가 js에 없었는데 #name 이렇게 하면 이제 쓸 수 있다.
 
- 원래 정적 필드도 안됐는데
  - 업데이트 되서 가능해졌다.
```javascript
  static #num = 10;
```

## 상속에 의한 클래스 확장
- class가 없던 시절에는 의사 클래스 상속 패턴을 활용해서 상속을 구현했는데 class생겨서 이런거 안해도 된다.
<img width="591" height="628" alt="image" src="https://github.com/user-attachments/assets/8e481b96-0689-4f21-8023-8098b80a7f90" />

- extends 키워드
<img width="550" height="334" alt="image" src="https://github.com/user-attachments/assets/8932bf37-88e9-46dd-99b0-f52f2515a042" />

- 동적 상속
  - 생성자 함수를 상속받아 클래스를 확장할 수도 있네 잘 쓰려나

- super
  - 상위 클래스를 초기화할 때 사용
  - 서브 클래스에서 super를 쓰기 전에는 this를 쓸 수 없다.

## 상속 클래스의 인스턴스 생성 과정
1. 서브클래스의 super호출
- 실제로 인스턴스를 생성하는 것은 사실 수퍼 클래스다
- js 는 수퍼클래스와 서브 클래스를 구분하기 위해 [[ConstructorKind]]에 "base" or "derived"가 들어있는 내부 슬롯을 가짐
```javascript
class Rectangle {
    constructor(width, height) {
      // ColorRectangle가 서브 클래스에서 빈 객체가 생성되고 Rectangle가 super()가 넘겨준 this를 받은 것
      // 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다.
      console.log(this);	// ColorRectangle {}
      // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다.
      console.log(new.target);	// ColorRectangle

```
2. 이렇게 수퍼클래스가 인스턴스를 초기화 시키고
3. 서브 클래스로 복귀한다 여기서 this를 수퍼클래스에서 받아서 ColorRectangle을 return 한다.

- 표준 빌트인 생성자 함수 확장
```javascript
// Array 생성자 함수를 상속받아 확장한 MyArray
class MyArray extends Array {
    // 중복된 배열 요소를 제거하고 반환한다: [1, 1, 2, 3] => [1, 2, 3]
    uniq() {
        return this.filter((v, i, self) => self.indexOf(v) === i);
    }

    // 모든 배열 요소의 평균을 구한다: [1, 2, 3] => 2
    average() {
        return this.reduce((per, cur) => pre + cur, 0) / this.length;
    }
}

const myArray = new MyArray(1, 1, 2, 3);
console.log(myArray);   // MyArray(4) [1, 1, 2, 3]

// MyArray.prototype.uniq 호출
console.log(myArray.uniq());    // MyArray(3) [1, 2, 3]
// MyArray.prototype.average 호출
console.log(myArray.average()); // 1.75
```
- 이 부분을 보면 return으로 MyArray를 받을 수 있다. MyArray에 있는 메소드를 연이어 호출할 수 있다.
