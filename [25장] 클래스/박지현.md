## 클래스
### 클래스는 프로토 타입의 문법적 설탕인가?
- 클래스는 프로토타입 기반의 인스턴스를 생성하지만 동일하게 동작하지는 않는다.
- 클래스는 super, extends 키워드가 지원되고 호이스팅이 발생하지 않는 것 처럼 동작한다.
- 그래서 클래스는 문법적 설탕이라기 보다 새로운 객체 생성 매커니즘이 더 합당하다.
### 클래스 정의
- 파스칼 케이스 사용해라
- 클래스는 함수다 js에서 함수는 일급객체다 그래서 클래스는 일급객체다.

### 클래스 호이스팅
- 클래스는 런타임 이전에 평가되어 함수 객체를 생성하는데 생성된 함수 객체는 생성자 함수(constructor)이다.
- 생성자 함수는 함수 정의가 평가되는 시점에 프로토타입도 생긴다.
- 클래스는 호이스팅이 안 일어나는 것 처럼 보이지만 let, const 키워드로 선언한 변수처럼 호이스팅 된다 TDZ에 빠진다.
- TDZ는 메모리에 등록이 되었지만 초기화가 안됬거나 위험해서 아직 못 쓰는 상태\

### 인스턴스 생성
- new를 붙이면 생성자 함수로 인식되고 안 붙이면 일반 함수로 인식됨 만드려면 new 반드시 붙여야 한다.

### 메서드
- 클래스 몸체에 정의할 수 있는 메서드는 생성자, 프로토타입 메서드 정적 메서드가 있다.
- constructor
  - 인스턴스 생성, 초기화를 위한 메서드
- 클래스가 평가되어 생성된 함수 객체나 클래스가 생성한 인스턴스에 constructor메서드가 없다!!
- constructor는 메서드로 해석되는 것이 아니라 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다.
<img width="200" height="200" alt="image" src="https://github.com/user-attachments/assets/bfe020e2-e001-4200-833a-4effae01c56a" />
- 프로토타입 메서드를 넣는 방법은 객체에 Person.prototype으로 넣거나 클래스 안에서 프로토타입 메서드를 선언하면 된다.
- 결국 클래스는 생성자 함수랑 인스턴스를 쉽게 만들어 주는 생성자 함수다
- 정적 메서드
  - 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
  - 클래스에 바인딩 되어 함수 객체 평가 시점에 생김, 프로토타입 안에 생기는 것이 아닌 Person 클래스 안에 생긴다.
  - 그래서 프로토타입 체인상에 없어서 메서드를 상속받을 수 없고 Person.sayHi()이렇게 써야된다.
  - 정적 메서드는 그래서 this 못씀
  - 정적 메서드의 장점은 하나의 네임스페이스로 관련된 유틸 함수들을 모아놓으면 관리하고 구조화하기 쉽다.

### 클래스의 인스턴스 생성 과정
- new 연산자와 함께 클래스를 호출하면 클래스 내부 메서드 [[Constructor]]가 호출됨.
```javascript
class Person {
    constructor(name) {
        // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
        console.log(this);  // Parson {}
        console.log(Object.getPrototypeOf(this) === Person.prototype);  // true

        // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
        this.name = name;

        // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
    }
}
```
### 프로퍼티 
- 인스턴스 프로퍼티
  - constructor내부에 정의된 프로퍼티들
- 접근자 프로퍼티
  - 다른 데이터나 값을 읽거나 저장할 때 사용하는 접근자 함수 ex) get, set
  
