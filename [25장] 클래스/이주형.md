# 25장 클래스

## 25.1 클래스는 프로토타입의 문법적 설탕인가?
- 클래스는 **프로토타입 기반 상속을 단순화**한 문법적 설탕이다.
- 본질적으로 클래스도 **함수**이며, 내부 동작은 프로토타입 체인을 이용한다.
- 특징
  - `new` 없이 호출 불가
  - 내부 슬록 `[[IsClassConstructor]]` 보유 -> 일반 함수와 차이
  - 항상 **strict mode**로 동작


## 25.2 클래스 정의
- **클래스 선언문**
```js
class Person {}
const Foo = class {};
```
- 클래스는 일급 객체 -> 변수에 할당, 인수로 전달, 반환 가능

## 25.3 클래스 호이스팅
- 클래스 선언문도 호이스팅된다.
- 다만 `var`처럼 undefined로 초기화되지 않고, `let/const`처럼 **TDZ(Temproal Dead Zone)**에 들어간다.
- 따라서 선언 전에 참조 불가

  
## 25.4 인스턴스 생성
- 클래스는 반드시 `new` 연산자를 통해 호출해야 한다.
- 일반 함수 호출 불가.

  
## 25.5 메서드

### 25.5.1 constructor
- 인스턴스를 생성하고 초기화하는 특수 메서드.
- 클래스당 하나만 정의 가능
- 생략 시 빈 constructor 자동 제공
- 반환값이 없으면 암묵적으로 인스턴스 반환

  
### 25.5.2 프로토타입 메서드
- 클래스 내부에서 정의한 메서드는 인스턴스의 프로토타입에 등록된다.
- 모든 인스턴스가 공유하여 사용

### 25.5.3 정적 메서드
- `static` 키워드로 정의
- 인스턴스가 아닌 **클래스 자체에 바인딩** 된다.
- 인스턴스에서는 호출 불가


### 25.5.4 정적 메서드와 프로토타입 메서드의 차이
- **호출 주체**
  - 정적 메서드 -> 클래스에서 직접 호출
  - 프로토타입 메서드 -> 인스턴스에서 호출
- **this 바인딩**
  - 정적 메서드 -> 클래스 자신
  - 프로토타입 메서드 -> 호출한 인스턴스
 

### 25.5.5 클래스에서 정의한 메서드의 특징
- `[[Construct]]`를 갖지 않음 -> new로 호출 불가
- 내부적으로 **non-constructor**
- **열거 불가능(enumerable: false)**
- 암묵적으로 strict mode 적용


## 25.6 클래스의 인스턴스 생성 과정
1. 인스턴스 생성과 this 바인딩
   -> 암묵적으로 빈 객체 생성 후 this에 바인딩
2. 인스턴스 초기화
   -> constructor 실행으로 프로퍼티 추가/초기화
3. 인스턴스 반환
   -> 명시적으로 객체를 반환하지 않으면 this가 반환됨

   
## 25.7 프로퍼티

### 25.7.1 인스턴스 프로퍼티
- constructor 내부에서 `this`에 추가되는 프로퍼티

  
### 25.7.2 접근자 프로퍼티
- `get`, `set` 키워드 사용
```js
class Person {
  get name() { ... }
  set name(value) { ... }
}
```

### 25.7.3 클래스 필드 정의 제안
- 클래스 body에 직접 프로퍼티 선언 가능
```js
class Person {
  name = "Lee";
}
```

### 25.7.4 private 필드 정의 제안
- `#` 기호로 정의
```js
class Person {
  #name = "Lee";
  getName() { return this.#name; }
}
```

### 25.7.5 static 필드 정의 제안
- 클래스 자체에 바인딩되는 정적 프로퍼티
```js
class MyClass {
  static count = 0;
}
```

## 25.8 상속에 의한 클래스 확장

### 25.8.1 클래스 상속과 생성자 함수 상속
- 기존 프로토타입 체인 기반 상속을 클래스 문법으로 단순화


### 25.8.2 extends 키워드
- 클래스 간 상속 정의
```js
class Child extends Parent {}
```

### 25.8.3 동적 상속
- extends 오른쪽에는 **클래스뿐만 아니라 표현식**도 가능
```js
class Child extends (condition ? Parent1 : Parent2) {}
```

### 25.8.4 서브 클래스의 constructor
- 서브클래스에서 constructor 정의 시 **반드시 super 호출** 필요


### 25.8.5 super 키워드
- **super 호출**: 부모 클래스의 constructor 호출
- **super 참조**: 부모 클래스 메서드 호출
```js
super.method();
```


### 25.8.6 상속 클래스의 인스턴스 생성 과정
1. 서브클래스의 super 호출
2. 수퍼클래스의 인스턴스 생성과 this 바인딩
3. 수퍼클래스의 인스턴스 초기화
4. 서브클래스 constructor로의 복귀와 this 바인딩
5. 서브클래스의 인스턴스 초기화
6. 인스턴스 반환



### 25.8.7 표준 빌트인 생성자 함수 확장
- Array, Error 같은 **표준 빌트인 객체도 extends로 확장 가능.**
